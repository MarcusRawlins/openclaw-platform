# Finance Hub â€” Task 15: Natural Language Query Interface

> ðŸ¦ž Marcus Rawlins | v1.0 | 2026-02-28
> Parent PRD: Section 9.2 (Natural Language Queries)
> Phase: 3 â€” Reporting & Tax
> Dependencies: Tasks 1-14 complete (needs all report/transaction infrastructure)

---

## Objective

Add a chat-style natural language query interface to Finance Hub. Tyler types a question in plain English, Sonnet generates a safe SQL query, executes it, and returns a formatted table plus a natural language summary.

## Build Location

`/Users/marcusrawlins/.openclaw/workspace/finance-hub/`

## Context: What Already Exists

Read ALL of these before writing any code:

- `prisma/schema.prisma` â€” Full schema with all models
- `src/lib/db.ts` â€” Prisma client factory
- `src/lib/entities.ts` â€” EntityId type and entity config
- `src/lib/categorization/ai.ts` â€” Existing Anthropic API client (reuse the client setup)
- `src/lib/categorization/prompts.ts` â€” Example of how we structure Sonnet prompts
- `src/lib/reports/profit-loss.ts` â€” Example report query patterns
- `src/lib/reports/balance-sheet.ts` â€” More query patterns
- `src/lib/format.ts` â€” formatCents, formatCurrency, formatDate utilities
- `src/app/(dashboard)/[entity]/page.tsx` â€” Entity dashboard (for navigation context)

## Architecture

### New Files

```
src/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ (dashboard)/
â”‚   â”‚   â””â”€â”€ [entity]/
â”‚   â”‚       â””â”€â”€ query/
â”‚   â”‚           â””â”€â”€ page.tsx           # NLP query page
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ v1/
â”‚           â””â”€â”€ query/
â”‚               â””â”€â”€ route.ts          # POST /api/v1/query
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ query/
â”‚       â”œâ”€â”€ nl-to-sql.ts             # Sonnet prompt + SQL generation
â”‚       â”œâ”€â”€ sql-executor.ts          # Safe query execution with constraints
â”‚       â”œâ”€â”€ schema-context.ts        # Generate schema summary for Sonnet
â”‚       â””â”€â”€ __tests__/
â”‚           â””â”€â”€ nl-to-sql.test.ts    # Test prompt formatting + SQL validation
â”œâ”€â”€ components/
â”‚   â””â”€â”€ query/
â”‚       â”œâ”€â”€ QueryChat.tsx            # Chat-style input/output UI
â”‚       â”œâ”€â”€ QueryResult.tsx          # Table + summary renderer
â”‚       â””â”€â”€ QueryHistory.tsx         # Last 20 queries sidebar
```

### Add sidebar link

Update the entity sidebar/navigation to include a "Query" link with a chat icon.

## Detailed Requirements

### 1. API Endpoint

**POST /api/v1/query**

Request:
```typescript
interface QueryRequest {
  entityId: string           // Which entity to scope queries to
  question: string           // Natural language question (max 500 chars)
  conversationId?: string    // Optional: for follow-up context
}
```

Response:
```typescript
interface QueryResponse {
  id: string                 // UUID for this query
  question: string
  generatedSql: string       // The SQL that was generated (for transparency)
  results: Record<string, any>[]  // Query results as array of objects
  summary: string            // Natural language summary of results
  rowCount: number
  executionTimeMs: number
  timestamp: string          // ISO 8601
  confidential: true
}
```

Error response (400):
```typescript
interface QueryError {
  error: string
  message: string            // Human-readable explanation
  suggestion?: string        // Alternative phrasing suggestion
}
```

### 2. NL-to-SQL Generation (`nl-to-sql.ts`)

**Prompt structure for Sonnet:**

```typescript
interface NLToSQLInput {
  question: string
  entityId: string
  schemaContext: string       // Simplified schema description
  recentQueries?: Array<{    // Last 3 queries for context
    question: string
    sql: string
  }>
}
```

The system prompt must include:
1. Simplified schema (table names, column names, types, relationships) â€” generated by `schema-context.ts`
2. Hard constraints:
   - SELECT only. No INSERT, UPDATE, DELETE, DROP, ALTER, CREATE, TRUNCATE, GRANT.
   - No subqueries that modify data
   - Entity-scoped: all queries must filter by the current entity context
   - LIMIT 100 max rows (enforce in generated SQL)
   - No access to `users`, `api_keys`, or `audit_log` tables
   - All monetary columns are BIGINT cents â€” instruct Sonnet to divide by 100 for display
3. Example queries (hardcoded, 5-8 examples covering common patterns):
   - "What did we spend on marketing in January?" â†’ SELECT with category filter + date range
   - "Top 10 vendors by spend this quarter" â†’ GROUP BY + ORDER BY + LIMIT
   - "Unreconciled transactions for Chase checking" â†’ JOIN accounts + filter reconciled status
   - "Monthly revenue trend for the last 6 months" â†’ GROUP BY month + ORDER BY
   - "Outstanding invoices over 30 days" â†’ Invoice query with date math
   - "Compare Q1 expenses to Q1 last year" â†’ Two subqueries or CASE WHEN

**Sonnet must return structured JSON:**
```json
{
  "sql": "SELECT ...",
  "explanation": "This query finds...",
  "columns": [
    {"name": "category", "type": "text"},
    {"name": "total_cents", "type": "money", "displayAs": "currency"}
  ]
}
```

### 3. SQL Executor (`sql-executor.ts`)

Safety constraints enforced at the code level (defense in depth, don't rely solely on prompt):

```typescript
interface ExecutorConfig {
  maxRows: number           // 100
  timeoutMs: number         // 5000
  allowedTables: string[]   // Whitelist of queryable tables
  blockedKeywords: string[] // INSERT, UPDATE, DELETE, DROP, ALTER, etc.
}
```

Implementation:
1. Parse the generated SQL and validate against blocklist
2. Ensure SQL contains no semicolons (prevent multi-statement injection)
3. Execute using Prisma's `$queryRawUnsafe` with a read-only transaction
4. Enforce timeout via `statement_timeout` SET on the connection
5. Cap results at maxRows
6. Return results + execution time

If validation fails, return a clear error explaining why (e.g., "Cannot modify data through the query interface").

### 4. Schema Context Generator (`schema-context.ts`)

Generates a simplified schema description for the Sonnet prompt. This is NOT the raw Prisma schema â€” it's a curated summary:

```typescript
function generateSchemaContext(entityId: string): string
```

Include:
- Table names relevant to financial queries (transactions, transaction_lines, accounts, categories, invoices, invoice_lines, budgets, budget_lines, recurring_rules, tags)
- Column names and types (simplified)
- Key relationships (foreign keys)
- Enum values (TransactionStatus, InvoiceStatus, AccountType)
- Note that amounts are in cents (BIGINT)

Exclude:
- users, api_keys, audit_log tables
- Password hashes, encryption keys
- Internal system columns

### 5. Query UI (`query/page.tsx`)

Chat-style interface:
- Text input at bottom with send button
- Messages scroll upward (Tyler's questions on right, results on left)
- Results render as:
  - A data table (sortable columns)
  - A natural language summary below the table
  - The generated SQL in a collapsible "Show SQL" section
- Empty state: show 6-8 example questions as clickable chips
- Query history in a collapsible sidebar (last 20 queries, stored in localStorage)
- Loading state: "Thinking..." with a subtle animation
- Error state: show the error message with a suggestion for rephrasing

**Styling**: Dark theme consistent with existing pages. Use existing color tokens (`#1C1C1E`, `#2C2C2E`, `#F5F5F7`, `#0A84FF`, `#8E8E93`).

### 6. Query History (`QueryHistory.tsx`)

- Stored in localStorage (not database â€” these are ephemeral)
- Max 20 entries, FIFO
- Each entry: question text, timestamp, row count
- Clicking a history item re-runs the query
- Clear history button

### 7. Security

- All queries scoped to current entity (enforced in SQL executor, not just prompt)
- Anthropic API only (hard boundary â€” no local LLM)
- Rate limit: 10 queries per minute per user
- Audit log every query (question, generated SQL, row count, execution time)
- Response includes `confidential: true`
- Generated SQL visible to Tyler for transparency but NOT logged to any chat or memory file

## Testing Requirements

1. **Prompt formatting**: Verify schema context generation produces correct table/column list
2. **SQL validation**: Test that INSERT/UPDATE/DELETE/DROP are rejected
3. **Multi-statement rejection**: Verify semicolons in SQL are rejected
4. **Entity scoping**: Verify queries cannot access other entities' data
5. **Table allowlist**: Verify queries against users/api_keys/audit_log are rejected
6. **Row limit**: Verify LIMIT is enforced even if Sonnet doesn't include it
7. **Timeout**: Verify long-running queries are killed
8. **Mock Sonnet**: All tests must mock the Anthropic API. No real API calls.
9. **Error handling**: Test malformed Sonnet responses (invalid JSON, missing fields)
10. **History management**: Test localStorage FIFO behavior at 20-entry cap

## Constraints

- Money is BIGINT cents. Always.
- Anthropic API only. No local LLM.
- Sonnet (not Opus) for queries â€” cost-effective for classification/generation.
- Max 500 character questions.
- Max 100 result rows.
- 5 second query timeout.
- `bun test` and `bun run build` must pass.
- Git commit: `ðŸ¦« Brunel: Task 15 â€” Natural Language Query Interface`

## Review

Walt must score 95%+. Marcus (Opus) must score 99%+.
